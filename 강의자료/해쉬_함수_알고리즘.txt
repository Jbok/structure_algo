Hash Table

해쉬 테이블은 dynamic set을 구현하는 효과적인 방법
=> 가정이 적절하다면 탐색, 삽입, 삭제의 평균 시간복잡도 O(1), 보통 최악의 경우 O(n)

해쉬 함수(hash function) h를 사용하여 키 k를 T[h(k)]에 저장. //키 k가 h(k)로 해슁되었다고 말함
index = h(k); //즉 각 키에 대한 해쉬 함수값을 그 키를 저장할 배열 인덱스로 사용.

모든 키들을 자연수로 해석한다.
ex. 문자열 ASCII 코드: C=67, L=76, R=82 , S=83.
    문자열 CLRS: (67*128^3) + (76*128^2) + (82*128) + (83*128^0) = 141,764,947


#충돌(collision)
두 개 이상의 키가 동일한 위치로 해슁되는 경우 //서로 다른 두 키 k1, k2에 대해서 h(k1) = h(k2)
즉, 충돌은 발생할 수 밖에 없고 대처 방법이 필요함. => chaining, open addressing.
1. Chaining: 동일한 장소로 해슁된 모든 키들을 하나의 연결 리스트로 저장.
  1) Insertion
    :연결 리스트의 맨 앞에 삽입, 시간복잡도 O(1) //중복 저장이 허용되지 않는다면 시간 복잡도는 리스트의 길이에 비례
  2) Search
    :연결 리스트에서 순차 검색. //시간복잡도는 키가 저장된 리스트의 길이에 비례
  3) Deletion
    :리스트로 부터 키를 검색 후 삭제 //키를 찾은 후에는 O(1)시간에 삭제 가능  
  최악의 경우는 모든 키가 하나의 슬롯으로 해슁되는 경우. 탐색시간은 O(n)+해쉬함수 계산시간.
  //평균 시간 복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정

#SUHA(Simple Uniform Hashing Assumption)
1. 각각의 키가 모든 슬롯들에 균등한 확률로 독립적으로 해슁된다는 가정. (hash함수는 deterministic하므로 현실에서는 불가능)
2. Load factor a= n/m; (n: 테이블에 저장될 키의 개수, m: 해쉬테이블의 크기(연결 리스트의 개수), 각 슬롯에 저장된 키의 평균 개수)
3. 연결리스트 T[j]의 길이를 nj라고 하면 E[nj]= Load factor a;
4. 만약 n=O(m)이면 평균 검색시간은 O(1)

#Open Addressing - INSERT, SEARCH
모든 키를 해쉬 테이블 자체에 저장, 테이블의 각 칸(slot)에는 1개의 키만 저장
충돌 해결 기법: Linear probing, Quadratic probing, Double hashing ...

1. Linear probing
: 충돌이 일어나면 h(k), h(k)+1, h(k)+2, ... 순서(circular)로 검사하여 처음으로 빈 슬롯에 저장. (단점: 값들이 뭉쳐있는 clustering)
-search: h(k), h(k)+1, h(k)+2, ... 순서(circular)로 검사하여 빈 슬롯이 나타나면 찾는 값은 존재하지 않는다.
-단점: primary cluster에 의해서 하나의 clutser가 점점 더 커지는 경향이 생김
2. Quadratic probing: probing의 값을 제곱으로 바꿈
:h(k), h(k) + 1^2, h(k)+2^2, h(k)+3^2 ... //offset은 일정하다.
3. Double hasing: 서로 다른 두 해쉬 함수 h1과 h2를 이용함.
: h(k, i) = ( h1(k) + i*h2(k) ) mod m  //h2(의 해쉬값은 0이 되어서는 안된다.)
: h2는 offset. 즉 k의 값에 따라서 h2에 의한 offset이 달라진다.

#Open Addressing - DELETION
: 단순히 키를 삭제할 경우 문제가 발생한다.
ex. 만약 같은 해쉬함수값을 갖는 A B, C를 순서대로 삽입한 후 B가 삭제가 되면 A와 C의 사이의 값이 비어서 B이후의 값에 접근할 수 없다.
이럴경우 B의 삭제와 함께 이전에 값이 있었다는 flag를 주는 방법이 있지만 한계가 있는 좋지 못한 방법이다.

#좋은 해쉬 함수란?
: 현실에서는 키들이 랜덤하지 않음, 따라서 키들의 통계적 분포를 알고 있다면 이를 이용해서 해쉬 함수를 고안해야 하지만 현실적으로 어려움이 있다.
즉, 키들이 어떠한 특정한 패턴에 상관 없이 해쉬 함수값이 불규칙적이어야 한다.

#Division 기법 
: h(k) = k mod m //대부분의 기법에서 마지막으로 사용하는 방식
장점: 한번의 mod연산으로 계산. 따라서 빠름.
단점: 어떤 m값에 대해서는 해쉬 함수값이 키값의 특벙 부분에 의해서 결정 ex.) m=2^p이면 키의 하위 p bit가 해쉬 함수값이된다.
#Multiplication 기법
: 0<A<1 상수 A, kA의 소수 부분만을 택하고 소수부분에 m을 곱하고 소숫점 아래를 버린다.